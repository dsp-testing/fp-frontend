access_log off;
error_log /dev/stdout info;
charset utf-8;
lua_package_path '~/lua/?.lua;;';
lua_shared_dict discovery 1m;
lua_shared_dict jwks 1m;
lua_code_cache on; # Need to be set for session storage to work.
proxy_buffering off;
resolver "${RESOLVER}";
tcp_nodelay off;
tcp_nopush on;
gzip on;
gzip_proxied any;
underscores_in_headers on;
gzip_types
    text/css
    text/javascript
    text/xml
    text/plain
    application/javascript
    application/x-javascript
    application/json
    application/xml
    application/rss+xml
    application/atom+xml
    font/truetype
    font/opentype
    image/svg+xml;

server {
    listen "${APP_PORT}";
    root "${APP_DIR}";
    server_name  _;
    error_page 404 @rewrites;

    # Will protect the whole server. this prevents users of beeing logged out if they stay in the app
    # for a prolonged period of time.
    set $proxy_cookie "";
    set $session_secret "${OIDC_PASSWORD}";

    access_by_lua_block {
        local app_callback_path = "${APP_CALLBACK_PATH}"
        local app_login_path = "${APP_LOGIN_PATH}"
        local callback_host = "https://" .. ngx.var.host

        if ngx.var.host == "localhost" then
            callback_host = "http://localhost:" .. ngx.var.server_port
        end

        local opts = {
            redirect_uri = callback_host .. app_callback_path,
            client_id = "${OIDC_AGENTNAME}",
            client_secret = "${OIDC_PASSWORD}",
            scope = "openid",
            ssl_verify = "no",
            token_endpoint_auth_method = "client_secret_basic",
            discovery = "${OIDC_HOST_URL}" .. "/oauth2/.well-known/openid-configuration",
            session_contents = {
                enc_id_token = true
            }
        }

        -- starting session manual to set some default cookies.
        local session = require("resty.session").start()
        if ngx.var.cookie_ADRUM and ngx.var.cookie_ADRUM ~= session.data.ADRUM then
            session.data.ADRUM = ngx.var.cookie_ADRUM
        end

        local res, err = require("resty.openidc").authenticate(opts, nil, nil, session)

        if err then
            ngx.status = 500
            ngx.say(err)
            ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
        end

        if ngx.var.uri == app_callback_path or ngx.var.uri == app_login_path then
            return ngx.redirect("/")
        end

        local proxy_cookie = {}
        -- adding ADRUM cookie if existant
        if session.data.ADRUM then
            proxy_cookie.ADRUM = session.data.ADRUM
        end

        if ngx.var.cookie_ADRUM then
            proxy_cookie.ADRUM = ngx.var.cookie_ADRUM
        end

        -- adding ID_token if logged in
        if session.data.enc_id_token then
            proxy_cookie.ID_token = session.data.enc_id_token
        end

        -- pass ADRUM(EUM) cookie if present
        local proxy_cookie_string = ""
        for k,v in pairs(proxy_cookie) do
            proxy_cookie_string = proxy_cookie_string .. k .. "=" .. v ..";"
        end
        ngx.var.proxy_cookie = proxy_cookie_string
    }

    # saving ADRUM(EUM) cookie for subsequent requests
    # as this is done on the first request of a session data will be correct for the rest.
    header_filter_by_lua_block {
        local session = require("resty.session").open()
        if session.data.enc_id_token and ngx.var.cookie_ADRUM and ngx.var.cookie_ADRUM ~= session.data.ADRUM then
            session.data.ADRUM = ngx.var.cookie_ADRUM
            session:save()
        end
    }
    # Server headers. Will be overwritten if you set them in blocks.
    proxy_set_header    Connection "";
    proxy_set_header    Referer $http_referer;
    proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header    X-NginX-Proxy true;
    proxy_set_header    X-Real-IP $remote_addr;
    proxy_set_header    Cookie $proxy_cookie;
    add_header          X-Application-Id "${APP_NAME} ${APP_VERSION} med proxy mot ${APP_API_GATEWAY}";
    add_header          X-Debug-Cookie $proxy_cookie;
    add_header          X-Debug-Proxy-Host 'http://$proxy_host/ $scheme://$host/';
    add_header          X-Debug-Forwarded-For $proxy_add_x_forwarded_for;
    add_header          X-Debug-Forwarded-Host $host:$server_port;

    # Lanuage files are served from disk
    location /fpsak/sprak/ {
        alias /app/i18n/;
    }

    # Simple Proxy to backend
    location  /fpsak/api/ {
        proxy_pass              "${APP_API_GATEWAY}/fpsak/api/";
        proxy_redirect          "${APP_API_GATEWAY}" "http://$host:${APP_PORT}";
        proxy_http_version      1.1;
        proxy_ssl_verify        off;
    }

    # Health check for NAIS
    location = /health/isAlive {
        return 200 "Application:UP";
        add_header Content-Type text/plain;
    }

    # Readiness check for NAIS
    location = /health/isReady {
        return 200 "Application:READY";
        add_header Content-Type text/plain;
    }

    ## All static files will be served directly.
    location ~* ^.+\.(?:css|cur|js|jpe?g|gif|htc|ico|png|html|xml|otf|ttf|eot|woff|svg)$ {
        access_log off;
        expires 365d;

        ## No need to bleed constant updates. Send the all shebang in one fell swoop.
        tcp_nodelay off;

        ## Set the OS file cache.
        open_file_cache max=3000 inactive=120s;
        open_file_cache_valid 45s;
        open_file_cache_min_uses 2;
        open_file_cache_errors off;
    }

    # To make sure any assets can get through :)
    location "${APP_PATH_PREFIX}" {
        # Hvis vi tillater browser-caching vil vi ikke ha nedetidsfri deploy (!)
        add_header Cache-Control no-cache;
        try_files $uri @rewrites;
    }

    # If no asset matches, send it to your javascript app. Hopefully it's a route in the app!
    location @rewrites {
        #add_header Cache-Control no-cache;
        rewrite ^(.+)$ /index.html last;
    }
}
